package org.twinecoin.test.vectors;

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Random;

import org.twinecoin.test.crypt.SHA256;

/**
 * Class to generate test vectors for the tw_sha256 class.<br>
 * <br>
 * This ensures that the test vectors are generated by a separate
 * implementation.
 */
public class SHA256TestVectors {

	private final static byte[] H256_MAX = new byte[32];
	private final static byte[] H256_ZERO = new byte[32];

	static {
		Arrays.fill(H256_MAX, (byte) 0xFF);
	}

	public static List<String> generateVectors() {
		Random r = getRandom();

		List<List<byte[]>> pair = generateHashList(r);

		List<String> lines = new ArrayList<String>();

		lines.addAll(generateH256BinaryOperatorVectors(pair.get(0), pair.get(1)));
		lines.add("");

		List<byte[]> messages = generateTestMessages(r);
		lines.addAll(generateSHA256Vectors(messages));

		return lines;
	}

	public static Random getRandom() {
		Random r = new Random();

		// Seed random so that results are consistent
		r.setSeed(0x280e788cff6ec2bbL);
		return r;
	}

	public static List<List<byte[]>> generateHashList(Random r) {
		List<byte[]> aList = new ArrayList<byte[]>();
		List<byte[]> bList = new ArrayList<byte[]>();

		/**
		 * Extremes
		 */
		aList.add(H256_ZERO);
		bList.add(H256_ZERO);

		aList.add(H256_ZERO);
		bList.add(H256_MAX);

		aList.add(H256_MAX);
		bList.add(H256_ZERO);

		aList.add(H256_MAX);
		bList.add(H256_MAX);

		/**
		 * Almost equal (0 - 3 bit flips)
		 */
		for (int i = 0; i < 300; i++) {
			byte[] aArray = new byte[32];
			byte[] bArray = new byte[32];
			r.nextBytes(aArray);
			System.arraycopy(aArray, 0, bArray, 0, aArray.length);

			int bitFlips = r.nextInt(4);
			for (int j = 0; j < bitFlips; j++) {
				int k = r.nextInt(32);
				bArray[k] ^= (byte) (1 << r.nextInt(8));
			}

			aList.add(aArray);
			bList.add(bArray);
		}

		/**
		 * One byte different
		 */
		for (int i = 0; i < 300; i++) {
			byte[] aArray = new byte[32];
			byte[] bArray = new byte[32];
			r.nextBytes(aArray);
			System.arraycopy(aArray, 0, bArray, 0, aArray.length);

			bArray[r.nextInt(32)] = (byte) r.nextInt();

			aList.add(aArray);
			bList.add(bArray);
		}

		/**
		 * Purely random vectors (50% chance of equal)
		 */
		for (int i = 0; i < 500; i++) {
			byte[] aArray = new byte[32];
			byte[] bArray = new byte[32];
			r.nextBytes(aArray);
			if (r.nextBoolean()) {
				System.arraycopy(aArray, 0, bArray, 0, aArray.length);
			} else {
				r.nextBytes(bArray);
			}

			aList.add(aArray);
			bList.add(bArray);
		}

		List<List<byte[]>> pair = new ArrayList<List<byte[]>>(2);
		pair.add(aList);
		pair.add(bList);
		return pair;
	}

	public static List<byte[]> generateTestMessages(Random r) {
		List<byte[]> messages = new ArrayList<byte[]>();

		/**
		 * Extremes
		 */
		messages.add(new byte[0]);
		messages.add("a".getBytes(StandardCharsets.US_ASCII));
		messages.add("ab".getBytes(StandardCharsets.US_ASCII));
		messages.add("abc".getBytes(StandardCharsets.US_ASCII));
		messages.add("The quick brown fox jumps over the lazy dog".getBytes(StandardCharsets.US_ASCII));
		messages.add("The quick brown fox jumps over the lazy dog.".getBytes(StandardCharsets.US_ASCII));

		/**
		 * Purely random vectors
		 */
		for (int i = 0; i < 500; i++) {
			int mask = (1 << (r.nextInt(10))) - 1;
			byte[] message = new byte[r.nextInt() & mask];
			r.nextBytes(message);
			messages.add(message);
		}

		return messages;
	}

	public static List<String> generateH256BinaryOperatorVectors(List<byte[]> aList, List<byte[]> bList) {
		List<String> lines = new ArrayList<String>();

		lines.add("typedef struct _tw_h256_test_vector {");
		lines.add("  tw_h256 a;             // a");
		lines.add("  tw_h256 b;             // b");
		lines.add("  int a_equal_b;         // a == b");
		lines.add("} tw_h256_test_vector;");
		lines.add("");

		lines.add("tw_h256_test_vector h256_test_vectors[] =");
		lines.add("  {");

		String align = "                                                                                               ";
		align += "                                                                                                ";

		for (int i = 0; i < aList.size(); i++) {
			byte[] a = aList.get(i);
			byte[] b = bList.get(i);

			lines.add("    // Vector " + i);
			lines.add("    {");
			lines.add("      " + Convert.bytesToH256(a) + ",    // a");
			lines.add("      " + Convert.bytesToH256(b) + ",    // b");
			lines.add("      " + (Arrays.equals(a, b) ? "1," : "0,") + align + "    // equals");
			lines.add("    " + ((i == aList.size() - 1) ? "}" : "},"));
		}
		lines.add("  };");
		lines.add("");
		lines.add("#define H256_TEST_VECTORS_LENGTH " + aList.size());

		return lines;
	}

	public static List<String> generateSHA256Vectors(List<byte[]> messages) {
		List<String> lines = new ArrayList<String>();

		List<byte[]> hashes = new ArrayList<byte[]>(messages.size());
		MessageDigest md = SHA256.getSHA256MessageDigest();

		for (int i = 0; i < messages.size(); i++) {
			byte[] message = messages.get(i);

			md.reset();
			byte[] hash = md.digest(message);

			hashes.add(hash);
		}

		lines.add("tw_u8* tw_h256_test_vector_messages[] = {");

		for (byte[] message : messages) {
			lines.add("    " + Convert.bytesToU8(message, false) + ",");
		}

		lines.add("  };");

		lines.add("int tw_h256_test_vector_message_lengths[] = {");

		for (byte[] message : messages) {
			lines.add("    " + message.length + ",");
		}

		lines.add("  };");

		lines.add("tw_h256 tw_h256_test_vector_hashes[] = {");

		for (byte[] hash : hashes) {
			lines.add("    {" + Convert.bytesToU8(hash, true) + "},");
		}

		lines.add("  };");
		lines.add("");
		lines.add("#define SHA256_TEST_VECTORS_LENGTH " + messages.size());

		return lines;
	}
}