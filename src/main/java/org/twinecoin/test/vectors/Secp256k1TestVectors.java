package org.twinecoin.test.vectors;

import java.math.BigInteger;
import java.security.interfaces.ECPrivateKey;
import java.security.interfaces.ECPublicKey;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Random;

import org.bouncycastle.util.encoders.Hex;
import org.twinecoin.test.crypt.Secp256k1;

/**
 * Class to generate test vectors for the tw_u256 class.<br>
 * <br>
 * This ensures that the test vectors are generated by a separate
 * implementation.
 */
public class Secp256k1TestVectors {

	public static List<String> generateVectors() {
		Random r = getRandom();

		List<BigInteger> aList = generatePrivateKeyBigIntegerList(r);

		List<String> lines = new ArrayList<String>();

		lines.addAll(generateSecp256k1Vectors(aList, r));

		return lines;
	}

	public static Random getRandom() {
		Random r = new Random();

		// Seed random so that results are consistent
		r.setSeed(0x280e788cff6ec2bbL);
		return r;
	}

	public static List<BigInteger> generatePrivateKeyBigIntegerList(Random r) {
		List<BigInteger> integerList = new ArrayList<BigInteger>();

		/**
		 * Extremes
		 */
		integerList.add(U256TestVectors.U256_ZERO);
		integerList.add(U256TestVectors.U256_MAX);
		integerList.add(Secp256k1.getP().add(BigInteger.ONE));
		integerList.add(Secp256k1.getP());
		integerList.add(Secp256k1.getP().subtract(BigInteger.ONE));
		integerList.add(Secp256k1.getOrder().add(BigInteger.ONE));
		integerList.add(Secp256k1.getOrder());
		integerList.add(Secp256k1.getOrder().subtract(BigInteger.ONE));

		/**
		 * Purely random vectors, with some half width
		 */
		for (int i = 0; i < 500; i++) {
			integerList.add(new BigInteger(r.nextBoolean() ? 256 : 128, r));
		}
		return integerList;
	}

	public static List<String> generateSecp256k1Vectors(List<BigInteger> aList, Random r) {
		List<String> lines = new ArrayList<String>();

		lines.add("tw_u8* tw_secp256k1_test_vector[] = {");

		int longCount = 0;
		int shortCount = 0;

		byte[] sigLen = new byte[1];
		byte[] pubLen = new byte[1];
		byte[] sigValid = new byte[1];
		byte[] sigValidEncode = new byte[1];
		byte[] pubKeyValid = new byte[1];
		byte[] messageHash = new byte[32];

		int i = 0;
		int vector = 0;
		while (longCount < 490 || shortCount < 10) {
			BigInteger k;
			if (i < aList.size()) {
				k = aList.get(i);
			} else {
				k = new BigInteger(256, r);
			}
			i++;

			ECPrivateKey pri;
			ECPublicKey pub;
			byte[] signature;
			if (BigInteger.ZERO.equals(k) || k.compareTo(Secp256k1.getOrder()) >= 0) {
				continue;
			}

			r.nextBytes(messageHash);

			pri = Secp256k1.getECPrivateKey(k);
			pub = Secp256k1.getECPublicKey(pri);

			signature = Secp256k1.sign(pri, messageHash);

			BigInteger s = Convert.asn1toS(signature);
			if (s == null) {
				continue;
			}

			if (signature.length >= 0x46 && longCount >= 490) {
				continue;
			}

			if (s.compareTo(Secp256k1.getOrder().divide(BigInteger.valueOf(2))) > 0) {
				sigValid[0] = 0;
			} else {
				sigValid[0] = 1;
			}

			sigValidEncode[0] = 1;
			pubKeyValid[0] = 1;

			if (signature.length > 255) {
				throw new IllegalStateException("Signature length exceeds valid range");
			}

			byte[] pubEncoded;

			// Valid signature with compressed key
			lines.add("    // Vector " + (vector++));

			pubEncoded = Secp256k1.encodeDER(pub, true);
			sigLen[0] = (byte) signature.length;
			pubLen[0] = (byte) pubEncoded.length;
			lines.add("    " +
								Convert.bytesToU8(sigValid, true) + ", "  + Convert.bytesToU8(sigValidEncode, true) + ", "  + Convert.bytesToU8(pubKeyValid, true) + ", " +
								Convert.bytesToU8(sigLen, true) + ", " + Convert.bytesToU8(pubLen, true) + ",");
			lines.add("    " + Convert.bytesToU8(signature, true) + ",");
			lines.add("    " + Convert.bytesToU8(pubEncoded, true) + ",");
			lines.add("    " + Convert.bytesToU8(messageHash, true) + ",");
			lines.add("");

			// Valid signature with uncompressed key
			lines.add("    // Vector " + (vector++));

			pubEncoded = Secp256k1.encodeDER(pub, false);
			sigLen[0] = (byte) signature.length;
			pubLen[0] = (byte) pubEncoded.length;
			lines.add("    " +
					Convert.bytesToU8(sigValid, true) + ", "  + Convert.bytesToU8(sigValidEncode, true) + ", "  + Convert.bytesToU8(pubKeyValid, true) + ", " +
					Convert.bytesToU8(sigLen, true) + ", " + Convert.bytesToU8(pubLen, true) + ",");
			lines.add("    " + Convert.bytesToU8(signature, true) + ",");
			lines.add("    " + Convert.bytesToU8(pubEncoded, true) + ",");
			lines.add("    " + Convert.bytesToU8(messageHash, true) + ",");
			lines.add("");

			// Verify fails due to public key prefix error
			lines.add("    // Vector " + (vector++));

			sigValid[0] = 0;
			pubKeyValid[0] = 0;
			byte[] mutatedPubEncoded = Secp256k1.encodeDER(pub, r.nextBoolean());
			if (mutatedPubEncoded[0] == 0x02 || mutatedPubEncoded[0] == 0x03) {
				mutatedPubEncoded[0] &= 0xFE;
				mutatedPubEncoded[0] += (byte) (2 + r.nextInt(254));
			} else {
				mutatedPubEncoded[0] += (byte) (1 + r.nextInt(255));
			}
			sigLen[0] = (byte) signature.length;
			pubLen[0] = (byte) mutatedPubEncoded.length;
			lines.add("    " +
					Convert.bytesToU8(sigValid, true) + ", "  + Convert.bytesToU8(sigValidEncode, true) + ", "  + Convert.bytesToU8(pubKeyValid, true) + ", " +
					Convert.bytesToU8(sigLen, true) + ", " + Convert.bytesToU8(pubLen, true) + ",");
			lines.add("    " + Convert.bytesToU8(signature, true) + ",");
			lines.add("    " + Convert.bytesToU8(mutatedPubEncoded, true) + ",");
			lines.add("    " + Convert.bytesToU8(messageHash, true) + ",");
			lines.add("");

			// Verify fails due to public key mutation
			lines.add("    // Vector " + (vector++));

			mutatedPubEncoded = Arrays.copyOf(pubEncoded, pubEncoded.length);
			mutatedPubEncoded[r.nextInt(mutatedPubEncoded.length)] ^= (1 << (r.nextInt(8)));
			sigValid[0] = 0;
			pubKeyValid[0] = 0;

			sigLen[0] = (byte) signature.length;
			pubLen[0] = (byte) mutatedPubEncoded.length;
			lines.add("    " +
					Convert.bytesToU8(sigValid, true) + ", "  + Convert.bytesToU8(sigValidEncode, true) + ", "  + Convert.bytesToU8(pubKeyValid, true) + ", " +
					Convert.bytesToU8(sigLen, true) + ", " + Convert.bytesToU8(pubLen, true) + ",");
			lines.add("    " + Convert.bytesToU8(signature, true) + ",");
			lines.add("    " + Convert.bytesToU8(mutatedPubEncoded, true) + ",");
			lines.add("    " + Convert.bytesToU8(messageHash, true) + ",");
			lines.add("");

			// Verify fails due to message mutation
			lines.add("    // Vector " + (vector++));

			byte[] mutatedMessageHash = Arrays.copyOf(messageHash, messageHash.length);
			mutatedMessageHash[r.nextInt(32)] ^= (1 << (r.nextInt(8)));
			sigValid[0] = 0;
			pubKeyValid[0] = 1;

			pubEncoded = Secp256k1.encodeDER(pub, false);
			sigLen[0] = (byte) signature.length;
			pubLen[0] = (byte) pubEncoded.length;
			lines.add("    " +
					Convert.bytesToU8(sigValid, true) + ", "  + Convert.bytesToU8(sigValidEncode, true) + ", "  + Convert.bytesToU8(pubKeyValid, true) + ", " +
					Convert.bytesToU8(sigLen, true) + ", " + Convert.bytesToU8(pubLen, true) + ",");
			lines.add("    " + Convert.bytesToU8(signature, true) + ",");
			lines.add("    " + Convert.bytesToU8(pubEncoded, true) + ",");
			lines.add("    " + Convert.bytesToU8(mutatedMessageHash, true) + ",");
			lines.add("");

			// Verify fails due to badly encoded signature
			lines.add("    // Vector " + (vector++));

			byte[] mutatedSignature = Arrays.copyOf(signature, signature.length);
			int sStart = (signature[3] & 0xFF) + 0x04;

			// The signature can be invalidated by changing any of the 6 bytes
			//   0x30:   Section tag
			//   L:      Section Length field
			//     0x02:   Integer tag (R)
			//     L:      Integer length
			//     0x02:   Integer tag (S)
			//     L:      Integer length
			int[] indexes = new int[] {0, 1, 2, 3, sStart, sStart + 1};
			mutatedSignature[indexes[r.nextInt(indexes.length)]] += 1 + r.nextInt(255);
			sigValidEncode[0] = 0;
			sigValid[0] = 0;
			pubKeyValid[0] = 1;

			pubEncoded = Secp256k1.encodeDER(pub, false);
			sigLen[0] = (byte) mutatedSignature.length;
			pubLen[0] = (byte) pubEncoded.length;
			lines.add("    " +
					Convert.bytesToU8(sigValid, true) + ", "  + Convert.bytesToU8(sigValidEncode, true) + ", "  + Convert.bytesToU8(pubKeyValid, true) + ", " +
					Convert.bytesToU8(sigLen, true) + ", " + Convert.bytesToU8(pubLen, true) + ",");
			lines.add("    " + Convert.bytesToU8(mutatedSignature, true) + ",");
			lines.add("    " + Convert.bytesToU8(pubEncoded, true) + ",");
			lines.add("    " + Convert.bytesToU8(messageHash, true) + ",");
			lines.add("");

			if (signature.length >= 0x46) {
				longCount++;
			} else {
				shortCount++;
			}
		}

		lines.add("  };");

		lines.add("");

		int step = 8;
		int tests = 5;

		lines.add("#define SECP256K1_TEST_VECTORS_LENGTH " + ((longCount + shortCount) * step * tests));
		lines.add("#define SECP256K1_TEST_VECTORS_STEP " + step);

		return lines;
	}
}
